## Week7

### 자바 스레드

### 1. 자바 스레드란 무엇인가?  
자바 스레드는 자바 응용 프로그램 내에서 동시에 실행될 수 있는 작은 실행 단위.    
하나의 프로그램에서 여러 작업을 동시에 수행하여 응답성을 높이고 성능을 향상시킬 수 있게됨.  
운영체제가 CPU 시간을 할당하는 기본 단위로, 프로세스(JVM) 내에서 실행되는 여러 흐름.  



### 2. 자바 스레드와 JVM  
자바 스레드는 JVM 내에서 실행되는 실행 흐름이자, JVM에 의해 스케줄링되는 실행 단위 코드 블록.  
자바 스레드 객체(Thread 객체)의 .start() 메서드를 호출해야 비로소 JVM이 운영체제에 스레드 생성을 요청하고, 운영체제가 실제 스레드를 생성.  
이때 생성되는 스레드는 운영체제가 관리하는 실행 가능한 엔티티이며, CPU 시간을 할당받아 실행.  
JVM은 자바 스레드 객체와 운영체제 스레드를 연결하고 관리.  
JVM은 스레드 스케줄링 및 관리를 전적으로 담당.  
JVM은 TCB (Thread Control Block)라는 자료 구조를 사용하여 스레드 정보를 관리.  
JVM 스케줄러는 TCB 정보를 토대로 어떤 스레드를 실행시킬지 결정.  

### 3. 자바 스레드의 생명 주기  
**생성 (New)**: new Thread()를 통해 스레드 객체가 생성. 이 단계에서는 아직 스레드가 JVM에 등록되지 않음.  
**실행 가능 (Runnable)**: .start() 메서드를 호출하면 스레드가 JVM에 등록되고 실행 가능한 상태가 됨. JVM 스케줄러에 의해 CPU 시간을 할당받을 수 있는 상태.  
**실행 (Running)**: 스레드가 CPU 시간을 할당받아 run() 메서드의 코드를 실행하는 상태.  
**대기 (Waiting/Blocked/Sleeping)**: 스레드가 어떤 이벤트를 기다리거나, I/O 작업을 수행하거나, sleep() 메서드를 호출하여 일시 정지된 상태.  
**종료 (Terminated)**: run() 메서드의 실행이 완료되거나 예외가 발생하여 스레드가 종료된 상태.

### 4. 자바 스레드 생성 및 실행  
스레드 객체 생성: new Thread()를 통해 Thread 객체를 생성. 이 객체는 스레드의 정보를 담고 있음.    
> 이 객체는 스레드의 속성(이름, 우선순위 등)과 실행코드(run() 메서드)를 담고 있음
> 하지만 이 객체 자체가 스레드는 아닙니다. 단지 스레드를 표현하는 객체일 뿐.  
.start() 메서드 호출: .start() 메서드를 호출하면 JVM은 운영체제에 새로운 스레드 생성을 요청.  
운영체제 스레드 생성: 운영체제는 요청을 받아 새로운 스레드를 생성하고, 이 스레드를 실행 가능한 상태로 만듦. 이때 TCB(Thread Control Block)가 생성.  
자바 스레드와 운영체제 스레드 연결: JVM은 새로 생성된 운영체제 스레드와 자바 스레드 객체를 연결
run() 메서드 실행: JVM 스케줄러에 의해 스레드가 선택되면 run() 메서드가 호출되어 실행.  
> 주의: .start() 메서드를 호출해야 스레드가 JVM에 등록되어 스케줄링된다. run() 메서드를 직접 호출하면 새로운 스레드가 생성되지 않고 현재 스레드에서 실행됨.  

### 5. 자바 응용 프로그램, 스레드 코드, JVM, 스레드 정보 (TCB) 간의 관계  
자바 응용 프로그램: 스레드를 생성하고 실행하는 주체.  
스레드 코드: run() 메서드에 작성된, 스레드가 실행할 코드.  
JVM: 자바 응용 프로그램을 실행하고, 스레드를 생성하고 관리하는 환경.  
스레드 정보 (TCB): JVM이 스레드를 관리하기 위해 사용하는 정보.  
JVM은 자바 응용 프로그램의 스레드 코드를 실행하고, TCB 정보를 토대로 스레드를 스케줄링함.  

> .start() 메서드를 호출하면 JVM은 운영체제에 스레드 생성을 요청하고, 운영체제는 JVM의 요청에 따라 스레드를 생성하고, TCB를 생성하여 스레드 정보를 관리.   
> JVM은 운영체제의 스레드 API를 사용하여 간접적으로 TCB 정보에 접근. JVM은 이 TCB를 정보를통해 스레드의 상태를 확인하고 스케줄링 등 제어하는 것.  
> 예를 들어, Thread.sleep() 메서드를 호출하면 JVM은 운영체제에 스레드를 일시 정지시키도록 요청하고, 운영체제는 TCB의 상태를 "대기 중"으로 변경.


<br><hr><br>  


## Runnable 인터페이스의 장점  

#### Runnable 인터페이스는 run() 추상메서드만 있는 인터페이스.  

### `다중 상속 가능`:

`자바는 클래스의 다중 상속을 지원하지 않기 때문에,` 만약 Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없다.  
하지만 `Runnable 인터페이스`를 구현하면, `다른 클래스를 상속받으면서 동시에 스레드를 실행할 수 있다.`  
이것이 굳이 번거롭게라도 Runnable 인터페이스를 이용해서 스레드 객체를 생성하는 이유이다.

<br><hr><br>  

## Wait & notify  

근데 어차피 synchronized 블럭에서 작업끝난 스레드가 락 반환하면 대기중인 스레드들 중에서 하나가 실행 재개할텐데 굳이?    

물론, synchronized 블록 내에서 작업이 끝나면 해당 스레드가 락을 반환하게 되고, 대기 중인 스레드 중 하나가 락을 획득하여 실행된다.  

<br>

그러나 wait()와 notify() 메서드를 사용하는 이유는,  

+ 스레드 상태 제어: wait()를 호출한 스레드는 대기 상태로 전환되어, 다른 스레드가 notify()를 호출할 때까지 CPU 자원을 소모하지 않게됨. 즉, 이로 인해 시스템 자원 효율성이 향상.  

+ 조건적 실행: synchronized 블록 안에서 단순히 락을 반환하는 것만으로는 특정 조건이 충족될 때까지 대기하는 것이 어렵다.  
  예를 들어, 소비자가 데이터를 소비하기 위해서는 데이터가 준비되어 있어야 하는데, 이를 wait()와 notify()를 통해 개발자 의도대로,명시적으로 처리할 수 있게된다.
  소비자는 데이터가 준비되지 않으면 대기하고, 생산자는 데이터가 준비되면 소비자를 깨워서 작업을 진행하도록 할 수 있다.  

+ 스레드 간 협력: wait()와 notify()를 사용하면 스레드 간의 협력이 가능해진다. 생산자와 소비자 간의 관계를 명확하게 정의하고, 서로의 상태에 따라 적절하게 대기하고 실행할 수 있도록 함으로써.

  <br>

#### 결론적으로, synchronized는 락을 통해 스레드 간의 접근 제어를 제공하지만,  
#### `wait()와 notify()`는 더 세밀한 조건적 동기화를 가능하게 하여, 스레드가 언제 대기하고 언제 실행될지를 wait()와 notify()를 이용하여 명확히 제어해볼 수 있다.    
#### 단순 synchronized만 쓰는거보단, 이렇게 `wait()와 notify()`를 적절히 같이 사용해주면 멀티스레드 환경에서의 효율성을 더욱 높일 수 있다.  

<br>
